from dataclasses import dataclass

from fastapi import Depends

from app.config import get_config, Config
from app.core import exc
from app.core.crypto import decode_jwt
from app.core.models import User, TelegramAuthData
from app.core.repos import TelegramAuthRepo
from .base import AuthStrategy, LoginCredentials, AddAuthMethodData


@dataclass(frozen=True, kw_only=True)
class TelegramAddAuthMethodData(AddAuthMethodData):
    # 'name' inherited.
    token: str


@dataclass(frozen=True, kw_only=True)
class TelegramLoginCredentials(LoginCredentials):
    token: str


@dataclass(frozen=True, kw_only=True)
class TelegramTokenData:
    tg_user_id: str
    tg_username: str
    tg_first_name: str
    tg_last_name: str | None
    tg_photo_url: str | None


class TelegramAuthStrategy(AuthStrategy[TelegramLoginCredentials, TelegramAddAuthMethodData, TelegramAuthData]):
    """
    Authentication via telegram requires only valid Telegram JWT generated by nto-tg-jwt.
    """

    def __init__(self,
                 tg_auth_repo: TelegramAuthRepo = Depends(),
                 config: Config = Depends(get_config)
                 ):
        self.tg_auth_repo = tg_auth_repo
        self.config = config

    def _decode_tg_token(self, token: str) -> TelegramTokenData:
        try:
            payload = decode_jwt(token, [
                "tg_username",
                "tg_first_name",
                "tg_last_name",
                "tg_photo_url"
            ], self.config.telegram.token_secret)
        except exc.InvalidToken:
            raise exc.InvalidAuthData()

        return TelegramTokenData(
            tg_user_id=str(payload["sub"]),
            tg_username=str(payload["tg_username"]),
            tg_first_name=str(payload["tg_first_name"]),
            tg_last_name=str(payload["tg_last_name"]),
            tg_photo_url=str(payload["tg_photo_url"])
        )

    def add_auth_method_to_user(self, user: User, data: TelegramAddAuthMethodData):
        # Raises InvalidAuthData.
        token_auth_data = self._decode_tg_token(data.token)

        user.telegram_auth = TelegramAuthData(
            **token_auth_data.__dict__,
            user=user
        )

    async def login_for_user_model_or_fail(self, schema: TelegramLoginCredentials) -> User:
        # Raises InvalidAuthData.
        token_auth_data = self._decode_tg_token(schema.token)

        # Find auth data in db.
        auth_data_model = await self.tg_auth_repo.get_by_tg_user_id(token_auth_data.tg_user_id)
        if auth_data_model is None:
            raise exc.InvalidAuthData()

        # Token data is ok, update profile data.
        auth_data_model.update_fields(**token_auth_data.__dict__)
        await self.tg_auth_repo.update(auth_data_model)

        return auth_data_model.user
